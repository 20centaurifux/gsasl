\input texinfo                  @c -*- Texinfo -*-
@c Copyright (C) 2002, 2003 Simon Josefsson
@c This file is part of GNU SASL.
@c See below for copying conditions.

@setfilename gsasl.info
@documentencoding ISO-8859-1
@include version.texi
@settitle GNU SASL

@c Unify some of the indices.
@syncodeindex tp fn
@syncodeindex pg fn

@copying
This manual is last updated @value{UPDATED} for version
@value{VERSION} of GNU SASL.

Copyright @copyright{} 2002, 2003 Simon Josefsson.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''
@end quotation
@end copying

@dircategory GNU Libraries
@direntry
* libgsasl: (gsasl).	Simple Authentication and Security Layer Library.
@end direntry

@dircategory GNU utilities
@direntry
* gsasl: (gsasl)Invoking gsasl.		Command line interface to GNU SASL.
@end direntry

@titlepage
@title GNU SASL
@subtitle Simple Authentication and Security Layer for the GNU system
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Simon Josefsson
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU SASL

@insertcopying
@end ifnottex

@menu
* Introduction::                How to use this manual.
* Preparation::                 What you should do before using the library.
* Using the Library::           High level overview of how to use the library.
* Mechanisms::                  Mechanism specific information.
* Global Functions::            Functions to use in global context.
* Callback Functions::          Functions to set and get callbacks.
* Session Functions::           Functions used during a SASL session.
* Utilities::                   Functions for various odd things.
* Error Handling::              Error codes and such.
* Examples::                    Example code.
* Acknowledgements::            Whom to blame.

* Invoking gsasl::              Command line interface to the library.

Appendices

* Copying::                     How you can copy and share GNU SASL.
* Copying This Manual::         How you can copy and share this manual.

Indices

* Concept Index::               Index of concepts and programs.
* Function and Data Index::     Index of functions, variables and data types.
@end menu

@c **********************************************************
@c *******************  Introduction  ***********************
@c **********************************************************
@node Introduction
@chapter Introduction

GNU SASL is an implementation of the Simple Authentication and
Security Layer framework and a few common SASL mechanisms.  SASL is
used by network servers (e.g., IMAP, SMTP) to request authentication
from clients, and in clients to authenticate against servers.

GNU SASL contains of a library (`libgsasl'), a command line utility
(`gsasl') to access the library from the shell, and a manual.  The
library includes support for the framework (with authentication
functions and application data privacy and integrity functions) and at
least partial support for the CRAM-MD5, EXTERNAL, GSSAPI, ANONYMOUS,
PLAIN, SECURID, DIGEST-MD5, LOGIN, NTLM mechanisms.

The library is easily ported because it does not do network
communication by itself, but rather leaves it up to the calling
application.  The library is flexible with regards to the
authorization infrastructure used, as it utilizes callbacks into the
application to decide whether a user is authorized or not.  GNU SASL
has been ported to many Unix flavors.

@menu
* Getting Started::
* Features::
* SASL Overview::
* Supported Platforms::
* Commercial Support::
* Downloading and Installing::
* Bug Reports::
* Contributing::
@end menu

@node Getting Started
@section Getting Started

This manual documents the `Libgsasl' library programming interface.
All functions and data types provided by the library are explained.

The reader is assumed to possess basic familiarity with SASL and
network programming in C or C++.

This manual can be used in several ways.  If read from the beginning
to the end, it gives a good introduction into the library and how it
can be used in an application.  Forward references are included where
necessary.  Later on, the manual can be used as a reference manual to
get just the information needed about any particular interface of the
library.  Experienced programmers might want to start looking at the
examples at the end of the manual, and then only read up those parts
of the interface which are unclear.

@node Features
@section Features

`Libgsasl' might have a couple of advantages over other libraries doing
a similar job.

@table @asis
@item It's Free Software
Anybody can use, modify, and redistribute it under the terms of the
GNU General Public License (@pxref{Copying}).

@item It's thread-safe
No global variables are used and multiple library handles and session
handles may be used in parallell.

@item It's internationalized
It handles non-ASCII username and passwords and user visible strings
used in the library (error messages) can be translated into the users'
language.

@item It's portable
It should work on all Unix like operating systems, including Windows.
The library itself should be portable to any C89 system, not even
POSIX is required.

@end table

Note that the library do not implement any policy to decide whether a
certain user is ``authenticated'' or ``authorized'' or not.  Rather,
it uses callbacks back into the application to answer these questions.

@node SASL Overview
@section SASL Overview

This section describes SASL from a protocol point of view.

The Simple Authentication and Security Layer (SASL) is a method for
adding authentication support to connection-based protocols.  A
protocol includes a command for identifying and authenticating a user
to a server and for optionally negotiating a security layer for
subsequent protocol interactions.

The command has a required argument identifying a SASL mechanism.
SASL mechanisms are named by strings, from 1 to 20 characters in
length, consisting of upper-case letters, digits, hyphens, and/or
underscores.

If a server supports the requested mechanism, it initiates an
authentication protocol exchange.  This consists of a series of
server challenges and client responses that are specific to the
requested mechanism.  The challenges and responses are defined by the
mechanisms as binary tokens of arbitrary length.  The protocol's
profile then specifies how these binary tokens are then encoded for
transfer over the connection.

After receiving the authentication command or any client response, a
server may issue a challenge, indicate failure, or indicate
completion.  The protocol's profile specifies how the server
indicates which of the above it is doing.

After receiving a challenge, a client may issue a response or abort
the exchange.  The protocol's profile specifies how the client
indicates which of the above it is doing.

During the authentication protocol exchange, the mechanism performs
authentication, transmits an authorization identity (frequently known
as a userid) from the client to server, and negotiates the use of a
mechanism-specific security layer.  If the use of a security layer is
agreed upon, then the mechanism must also define or negotiate the
maximum cipher-text buffer size that each side is able to receive.

The transmitted authorization identity may be different than the
identity in the client's authentication credentials.  This permits
agents such as proxy servers to authenticate using their own
credentials, yet request the access privileges of the identity for
which they are proxying.  With any mechanism, transmitting an
authorization identity of the empty string directs the server to
derive an authorization identity from the client's authentication
credentials.

If use of a security layer is negotiated, it is applied to all
subsequent data sent over the connection.  The security layer takes
effect immediately following the last response of the authentication
exchange for data sent by the client and the completion indication
for data sent by the server.  Once the security layer is in effect,
the protocol stream is processed by the security layer into buffers
of cipher-text.  Each buffer is transferred over the connection as a
stream of octets prepended with a four octet field in network byte
order that represents the length of the following buffer.  The length
of the cipher-text buffer must be no larger than the maximum size
that was defined or negotiated by the other side.

@node Supported Platforms
@section Supported Platforms

Libgsasl has at some point in time been tested on the following
platforms.

@enumerate

@item Debian GNU/Linux 3.0 (Woody)
@cindex Debian

GCC 2.95.4 and GNU Make. This is the main development platform.
@code{alphaev67-unknown-linux-gnu}, @code{alphaev6-unknown-linux-gnu},
@code{arm-unknown-linux-gnu}, @code{hppa-unknown-linux-gnu},
@code{hppa64-unknown-linux-gnu}, @code{i686-pc-linux-gnu},
@code{ia64-unknown-linux-gnu}, @code{m68k-unknown-linux-gnu},
@code{mips-unknown-linux-gnu}, @code{mipsel-unknown-linux-gnu},
@code{powerpc-unknown-linux-gnu}, @code{s390-ibm-linux-gnu},
@code{sparc-unknown-linux-gnu}.

@item Debian GNU/Linux 2.1
@cindex Debian

GCC 2.95.1 and GNU Make. @code{armv4l-unknown-linux-gnu}.

@item Tru64 UNIX
@cindex Tru64

Tru64 UNIX C compiler and Tru64 Make. @code{alphaev67-dec-osf5.1},
@code{alphaev68-dec-osf5.1}.

@item SuSE Linux 7.1
@cindex SuSE

GCC 2.96 and GNU Make. @code{alphaev6-unknown-linux-gnu},
@code{alphaev67-unknown-linux-gnu}.

@item SuSE Linux 7.2a
@cindex SuSE Linux

GCC 3.0 and GNU Make. @code{ia64-unknown-linux-gnu}.

@item RedHat Linux 7.2
@cindex RedHat

GCC 2.96 and GNU Make. @code{alphaev6-unknown-linux-gnu},
@code{alphaev67-unknown-linux-gnu}, @code{ia64-unknown-linux-gnu}.

@item RedHat Linux 8.0
@cindex RedHat

GCC 3.2 and GNU Make. @code{i686-pc-linux-gnu}.

@item RedHat Advanced Server 2.1
@cindex RedHat Advanced Server

GCC 2.96 and GNU Make. @code{i686-pc-linux-gnu}.

@item Slackware Linux 8.0.01
@cindex RedHat

GCC 2.95.3 and GNU Make. @code{i686-pc-linux-gnu}.

@item Mandrake Linux 9.0
@cindex Mandrake

GCC 3.2 and GNU Make. @code{i686-pc-linux-gnu}.

@item IRIX 6.5
@cindex IRIX

MIPS C compiler, IRIX Make. @code{mips-sgi-irix6.5}.

@item AIX 4.3.2
@cindex AIX

IBM C for AIX compiler, AIX Make.  @code{rs6000-ibm-aix4.3.2.0}.

@item Microsoft Windows 2000 (Cygwin)
@cindex Windows

GCC 3.2, GNU make. @code{i686-pc-cygwin}.

@item HP-UX 11
@cindex HP-UX

HP-UX C compiler and HP Make. @code{ia64-hp-hpux11.22},
@code{hppa2.0w-hp-hpux11.11}.

@item SUN Solaris 2.8
@cindex Solaris

Sun WorkShop Compiler C 6.0 and SUN Make. @code{sparc-sun-solaris2.8}.

@item SUN Solaris 2.9
@cindex Solaris

Sun Forte Developer 7 C compiler and GNU
Make. @code{sparc-sun-solaris2.9}.

@item NetBSD 1.6
@cindex NetBSD

GCC 2.95.3 and GNU Make. @code{alpha-unknown-netbsd1.6},
@code{i386-unknown-netbsdelf1.6}.

@item OpenBSD 3.1 and 3.2
@cindex OpenBSD

GCC 2.95.3 and GNU Make. @code{alpha-unknown-openbsd3.1},
@code{i386-unknown-openbsd3.1}.

@item FreeBSD 4.7
@cindex FreeBSD

GCC 2.95.4 and GNU Make. @code{alpha-unknown-freebsd4.7},
@code{i386-unknown-freebsd4.7}.

@end enumerate

If you use Libgsasl on, or port Libgsasl to, a new platform please
report it to the author.

@node Commercial Support
@section Commercial Support

Commercial support is available for users of GNU SASL.  The kind of
support that can be purchased may include:

@itemize

@item Implement new features.
Such as a new SASL mechanism.

@item Port Libgsasl to new platforms.
This could include porting to an embedded platforms that may need
memory or size optimization.

@item Integrating SASL as a security environment in your existing project.

@item System design of components related to SASL.

@end itemize

If you are interested, please write to:

@verbatim
Simon Josefsson Datakonsult
Drottningholmsv. 70
112 42 Stockholm
Sweden

E-mail: simon@josefsson.org
@end verbatim

If your company provide support related to GNU SASL and would like to
be mentioned here, contact the author (@pxref{Bug Reports}).

@node Downloading and Installing
@section Downloading and Installing
@cindex Installation
@cindex Download

The package can be downloaded from several places, including:

@url{http://josefsson.org/gsasl/releases/}

The latest version is stored in a file, e.g.,
@samp{gsasl-0.0.42.tar.gz} where the @samp{0.0.42} indicate the
highest version number.

The package is then extracted, configured and built like many other
packages that use Autoconf.  For detailed information on configuring
and building it, refer to the @file{INSTALL} file that is part of the
distribution archive.

Here is an example terminal session that download, configure, build
and install the package.  You will need a few basic tools, such as
@samp{sh}, @samp{make} and @samp{cc}.

@example
$ wget -q http://josefsson.org/gsasl/releases/gsasl-0.0.8.tar.gz
$ tar xfz gsasl-0.0.8.tar.gz
$ cd gsasl-0.0.8/
$ ./configure
...
$ make
...
$ make install
...
@end example

After that gsasl should be properly installed and ready for use.

A few @code{configure} options may be relevant, summarized in the
table.

@table @code

@item --disable-client
@itemx --disable-server
If your target system require a minimal implementation, you may wish
to disable the client or the server part of the code.  This removes
symbols from the library, so if you attempt to link an application
that uses server functions to a libgsasl built with
@code{--disable-server}, you will get linker errors.

@item --disable-anonymous
@itemx --disable-external
@itemx --disable-plain
@itemx --disable-login
@itemx --disable-securid
@itemx --disable-ntlm
@itemx --disable-cram-md5
@itemx --disable-digest-md5
@itemx --disable-gssapi
@itemx --disable-kerberos_v5
Disable individual mechanisms (@pxref{Mechanisms}).

@item --without-stringprep
Disable internationalized string processing.  Note that this will
result in a SASL library that is only compatible with RFC 2222.  This
removes the symbols related to string processing from the library.

@end table

For the complete list, refer to the output from @code{configure
--help}.

@node Bug Reports
@section Bug Reports
@cindex Reporting Bugs

If you think you have found a bug in Libgsasl, please investigate it
and report it.

@itemize @bullet

@item Please make sure that the bug is really in Libgsasl, and
preferably also check that it hasn't already been fixed in the latest
version.

@item You have to send us a test case that makes it possible for us to
reproduce the bug.

@item You also have to explain what is wrong; if you get a crash, or
if the results printed are not good and in that case, in what way.
Make sure that the bug report includes all information you would need
to fix this kind of bug for someone else.

@end itemize

Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don't help the
development effort.

If your bug report is good, we will do our best to help you to get a
corrected version of the software; if the bug report is poor, we won't
do anything about it (apart from asking you to send better bug
reports).

If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please also send a
note.

Send your bug report to:

@center @samp{bug-gsasl@@gnu.org}

@node Contributing
@section Contributing
@cindex Contributing
@cindex Hacking

If you want to submit a patch for inclusion -- from solve a typo you
discovered, up to adding support for a new feature -- you should
submit it as a bug report (@pxref{Bug Reports}).  There are some
things that you can do to increase the chances for it to be included
in the official package.

Unless your patch is very small (say, under 10 lines) we require that
you assign the copyright of your work to the Free Software Foundation.
This is to protect the freedom of the project.  If you have not
already signed papers, we will send you the necessary information when
you submit your contribution.

For contributions that doesn't consist of actual programming code, the
only guidelines are common sense.  Use it.

For code contributions, a number of style guides will help you:

@itemize @bullet

@item Coding Style.
Follow the GNU Standards document (@pxref{top, GNU Coding Standards,,
standards}).

If you normally code using another coding standard, there is no
problem, but you should use @samp{indent} to reformat the code
(@pxref{top, GNU Indent,, indent}) before submitting your work.

@item Use the unified diff format @samp{diff -u}.

@item Return errors.
No reason whatsoever should abort the execution of the library.  Even
memory allocation errors, e.g. when malloc return NULL, should work
although result in an error code.

@item Design with thread safety in mind.
Don't use global variables.  Don't even write to per-handle global
variables unless the documented behaviour of the function you write is
to write to the per-handle global variable.

@item Avoid using the C math library.
It causes problems for embedded implementations, and in most
situations it is very easy to avoid using it.

@item Document your functions.
Use comments before each function headers, that, if properly
formatted, are extracted into Texinfo manuals and GTK-DOC web pages.

@item Supply a ChangeLog and NEWS entries, where appropriate.

@end itemize

@c **********************************************************
@c *******************  Preparation  ************************
@c **********************************************************
@node Preparation
@chapter Preparation

To use `Libgsasl', you have to perform some changes to your sources and
the build system.  The necessary changes are small and explained in the
following sections.  At the end of this chapter, it is described how the
library is initialized, and how the requirements of the library are
verified.

A faster way to find out how to adapt your application for use with
`Libgsasl' may be to look at the examples at the end of this manual
(@pxref{Examples}).

@menu
* Header::
* Initialization::
* Version Check::
* Building the source::
* Autoconf tests::
@end menu

@node Header
@section Header

All interfaces (data types and functions) of the library are defined
in the header file `gsasl.h'.  You must include this in all programs
using the library, either directly or through some other header file,
like this:

@example
#include <gsasl.h>
@end example

The name space of `Libgsasl' is @code{gsasl_*} for function names,
@code{Gsasl*} for data types and @code{GSASL_*} for other symbols.  In
addition the same name prefixes with one prepended underscore are
reserved for internal use and should never be used by an application.

@node Initialization
@section Initialization

`Libgsasl' must be initialized before it can be used.  The library is
initialized by calling @code{gsasl_init()} (@pxref{Global Functions}).
The resources allocated by the initialization process can be released
if the application no longer has a need to call `Libgsasl' functions,
this is done by calling @code{gsasl_done()}.

In order to take advantage of the internationalisation features in
`Libgsasl', such as translated error messages, the application must
set the current locale using @code{setlocale()} before initializing
`Libgsasl'.

In order to take advantage of the secure memory features in
`Libgcrypt', which subsequently makes sensitive key material used in
`Libgsasl' be allocated in secure memory, you need to initialize
secure memory in your application, and for some platforms even make
your application setuid root.  See the libgcrypt documentation for
more information.  Example code to initialize secure memory in your
code:

@example
#include <gcrypt.h>
...

int
main (int argc, char *argv[])
@{
...

  /* Check version of libgcrypt. */
  if (!gcry_check_version (GCRYPT_VERSION))
    die ("version mismatch\n");

  /* Allocate a pool of 16k secure memory.  This also drops priviliges
     on some systems. */
  gcry_control (GCRYCTL_INIT_SECMEM, 16384, 0);

  /* Tell Libgcrypt that initialization has completed. */
  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
  ...
@end example

If you do not do this, keying material will not be allocated in secure
memory, which for most application is not the biggest secure problem.
Note that `Libgsasl' has not been audited to make sure it only ever
stores passwords or keys in secure memory.

@node Version Check
@section Version Check

It is often desirable to check that the version of `Libgsasl' used is
indeed one which fits all requirements.  Even with binary compatibility
new features may have been introduced but due to problem with the
dynamic linker an old version is actually used.  So you may want to
check that the version is okay right after program startup.

@include texi/gsasl_check_version.texi

The normal way to use the function is to put something similar to the
following early in your @code{main()}:

@example
  if (!gsasl_check_version (GSASL_VERSION))
    @{
      printf ("gsasl_check_version() failed:\n"
              "Header file incompatible with shared library.\n");
      exit(1);
    @}
@end example

@node Building the source
@section Building the source
@cindex Compiling your application

If you want to compile a source file including the `gsasl.h' header
file, you must make sure that the compiler can find it in the
directory hierarchy.  This is accomplished by adding the path to the
directory in which the header file is located to the compilers include
file search path (via the @option{-I} option).

However, the path to the include file is determined at the time the
source is configured.  To solve this problem, `Libgsasl' uses the
external package @command{pkg-config} that knows the path to the
include file and other configuration options.  The options that need
to be added to the compiler invocation at compile time are output by
the @option{--cflags} option to @command{pkg-config libgsasl}.  The
following example shows how it can be used at the command line:

@example
gcc -c foo.c `pkg-config libgsasl --cflags`
@end example

Adding the output of @samp{pkg-config libgsasl --cflags} to the
compilers command line will ensure that the compiler can find the
`gsasl.h' header file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search path
(via the @option{-L} option).  For this, the option @option{--libs} to
@command{pkg-config libgsasl} can be used.  For convenience, this option
also outputs all other options that are required to link the program
with the `libgsasl' libarary (for instance, the @samp{-lidn}
option).  The example shows how to link @file{foo.o} with the `libgsasl'
library to a program @command{foo}.

@example
gcc -o foo foo.o `pkg-config libgsasl --libs`
@end example

Of course you can also combine both examples to a single command by
specifying both options to @command{pkg-config}:

@example
gcc -o foo foo.c `pkg-config libgsasl --cflags --libs`
@end example

@node Autoconf tests
@section Autoconf tests
@cindex Autoconf tests
@cindex Configure tests

If you work on a project that uses Autoconf (@pxref{top, GNU
Autoconf,, autoconf}) to help find installed libraries, the
suggestions in the previous section are not the entire story.  There
are a few methods to detect and incorporate Libgsasl into your
Autoconf based package.  The preferred approach, is to use Libtool in
your project, and use the normal Autoconf header file and library
tests.

@subsection Autoconf test via @samp{pkg-config}

If your audience is a typical GNU/Linux desktop, you can often assume
they have the @samp{pkg-config} tool installed, in which you can use
its Autoconf M4 macro to find and set up your package for use with
Shishi.  The following illustrate this scenario.

@example
AC_ARG_ENABLE(gsasl,
	AC_HELP_STRING([--disable-gsasl], [don't use GNU SASL]),
	gsasl=$enableval)
if test "$gsal" != "no" ; then
	PKG_CHECK_MODULES(GSASL, libgsasl >= 0.0.8,
			[gsasl=yes],
                        [gsasl=no])
	if test "$gsasl" != "yes" ; then
		sal=no
		AC_MSG_WARN([Cannot find GNU SASL, disabling])
	else
		gsasl=yes
		AC_DEFINE(USE_GSASL, 1, [Define to 1 if you want GNU SASL.])
	fi
fi
AC_MSG_CHECKING([if GNU SASL should be used])
AC_MSG_RESULT($gsasl)
@end example

@subsection Standalone Autoconf test using Libtool

If your package uses Libtool(@pxref{top, GNU Libtool,, libtool}), you
can use the normal Autoconf tests to find the Shishi library and rely
on the Libtool dependency tracking to include the proper dependency
libraries (e.g., Libidn).  The following illustrate this scenario.

@example
AC_CHECK_HEADER(gsasl.h,
	AC_CHECK_LIB(gsasl, gsasl_check_version,
		[gsasl=yes AC_SUBST(GSASL_LIBS, -lgsasl)],
		gsasl=no),
	gsasl=no)
AC_ARG_ENABLE(gsasl,
	AC_HELP_STRING([--disable-gsasl], [don't use GNU SASL]),
	gsasl=$enableval)
if test "$gsasl" != "no" ; then
	AC_DEFINE(USE_SASL, 1, [Define to 1 if you want GNU SASL.])
else
	AC_MSG_WARN([Cannot find GNU SASL, diabling])
fi
AC_MSG_CHECKING([if GNU SASL should be used])
AC_MSG_RESULT($gsasl)
@end example

@c **********************************************************
@c *****************  Using the Library  ********************
@c **********************************************************
@node Using the Library
@chapter Using the Library

After initialization of the library, the core part of the library is
run within a loop until it has finished.  The library is handed input
from the other protocol entity and results in output which is to be
sent to the other entity, or an error code.  The library does not send
data to the server itself, but only return it in buffers.  The main
interface to the library uses binary data, but since many common
protocols uses Base 64 encoded data, a wrapper around the main
function is also provided.

The following pseudo code illustrates how the library is used in a
simple client.  All the functions used are explained later on in this
manual.

@example
main()
@{
  Gsasl_ctx          *ctx;
  Gsasl_session_ctx  *cctx;
  char *input, output[BUFFERSIZE];
  size_t output_len;
  int rc;

  rc = gsasl_init (&ctx);
  if (rc != GSASL_OK)
    die(gsasl_strerror(rc));

  /* XXX Set callbacks here */

  /* Read supported SASL mechanism from server */
  input = read_from_client();

  /* Select a good mechanism */
  mech = gsasl_client_suggest_mechanism (ctx, input);
  if (mech == NULL)
    die("Cannot find any commonly agreed SASL mechanism...");

  /* Start to use it */
  res = gsasl_client_start (ctx, mech, &cctx);
  if (res != GSASL_OK)
    die(gsasl_strerror (rc));

  input = NULL;
  do
    @{
      /* Do one SASL step and unless we're done, send the output to
         server and read new data from server */

      rc = gsasl_client_step_base64 (cctx, input, output, BUFFERSIZE);
      if (rc != GSASL_NEEDS_MORE && rc != GSASL_OK)
        break;

      write_to_server(output);

      if (rc == GSASL_OK)
        break;

      input = read_from_server();
    @}
  while (rc == GSASL_NEEDS_MORE);

  if (rc != GSASL_OK)
    die("Authentication failed... %s\n", gsasl_strerror(rc);

  /* Client is now authenticated -- proceed with actual protocol... */

  gsasl_client_finish (cctx);
  gsasl_done (ctx);
@}
@end example

Notice the XXX comment that said you should specify the callbacks to
use there.  `Libgsasl' depend on callbacks to implement user
interaction (in the client) and user validation (in the server).  If
you don't specify any callbacks, very few mechanisms will be supported
(like EXTERNAL that don't need any additional information,
@pxref{EXTERNAL}).  Since we are building a simple client, we define
callbacks which are used by several SASL mechanisms to get username
and password.  We start by defining the function for querying the
username, following the prototype for
@code{Gsasl_client_callback_authentication_id} for the LOGIN mechanism
(@pxref{LOGIN}) .

@example
int
callback_username (Gsasl_session_ctx *ctx,
                   char *out,
                   size_t *outlen)
@{
  char username[BUFFERSIZE];

  if (out == NULL)
    *outlen = BUFFERSIZE;
  else
    @{
      fprintf(stdout, "Enter username: ");
      fgets(username, BUFFERSIZE, stdin);
      *outlen = strlen(BUFFERSIZE);
    @}

  return GSASL_OK;
@}
@end example

As you can see, this is a simplistic function that reads a username
from the user.  The callback for entering the password is similar and
follows the @code{Gsasl_client_callback_password} prototype:

@example
int
callback_password (Gsasl_session_ctx *ctx,
                   char *out,
                   size_t *outlen)
@{
  char password[BUFFERSIZE];

  if (out == NULL)
    *outlen = BUFFERSIZE;
  else
    @{
      fprintf(stdout, "Enter password: ");
      fgets(password, BUFFERSIZE, stdin);
      *outlen = strlen(BUFFERSIZE);
    @}

  return GSASL_OK;
@}
@end example

In reality, the program should probably inhibit echo of the password
to the terminal, but that is left as an exercise for the reader.

Now having implemented the callbacks, we are ready to replace the XXX
comment with real code that set the callbacks (@pxref{Callback
Functions}).  The following does it.

@example
  gsasl_client_callback_authentication_id_set(ctx, callback_username);
  gsasl_client_callback_authorization_id_set(ctx, callback_username);
  gsasl_client_callback_password_set(ctx, callback_password);
@end example

Notice that we use the same callback for the authentication identity
and the authorization identity.  In reality, this may be too
simplistic, but will do for an example.

The simple client is now complete, and will be able to support SASL
mechanisms such as PLAIN and CRAM-MD5.

Implementing a server is very similar to the client, the only
difference is that you use gsasl_server_*() functions instead of
gsasl_client_*() and instead of implementing Gsasl_client_* callbacks
implement some Gsasl_server_* callbacks.  See each mechanism
(@pxref{Mechanisms}) for details on which callbacks are required and
their prototype.

A note for server authors is in place, on the optional initial client
output (discussed in section 5.1 of RFC 2222).  In a server looking
similar to the code above, the first call to
@code{gsasl_server_step_base64} would have a @var{input} set to NULL.
The mechanisms interprete this as your protocol do not support initial
client output.  If the protocol in which you implement SASL supports
initial client output, the first call to
@code{gsasl_server_step_base64} should include a real buffer with the
initial client data.

One note for client authors is in place.  The code above aborts
processing if `Libgsasl' did not come out of the loop with a GSASL_OK
exit code.  It is a mistake to not require this, and instead only look
at what the server is sending you.  Even if the server said you are
authenticated, it does not always mean that the SASL mechanism is
satisfied.  This is specifically true for SASL client mechanisms which
perform server authentication.  Thus, if you only trust what the
server replied instead of requireing a GSASL_OK result, you may open
up for fake servers.  Don't shortcut the loop with a positive server
response.

@c **********************************************************
@c *******************  Mechanisms  *************************
@c **********************************************************
@node Mechanisms
@chapter Mechanisms

Different SASL mechanisms have different requirements on the
application using it.  Some simpler mechanisms, such as LOGIN and
PLAIN, are straight forward to hook into existing authentication
systems (such as @file{/etc/passwd} via PAM).  The client callback for
these mechanisms is easy to implement, the user is simply queried for
the username and password.  The server callbacks pass on the username
and password into the policy deciding authentication system
(e.g. PAM).

Other mechanism like CRAM-MD5, DIGEST-MD5, and SRP uses hashed
passwords.  The client callback are the same as for PLAIN and LOGIN.
However, the server do not receive the plaintext password via the
network but rather a hash of it.  Existing policy deciding systems
like PAM cannot handle this, so the server callback for these
mechanisms are more complicated.

Further mechanisms like GSSAPI (Kerberos 5) assume a specific
authentication system.  In theory this means that `Libgsasl' would not
need to interact with the application, but rather call this specific
authentication system directly.  However, some callbacks are supported
anyway, to modify the behaviour of how the specific authentication
system is used.

Special mechanisms like EXTERNAL and ANONYMOUS are entirely dependent
on callbacks.

@menu
* EXTERNAL::                Authentication via out of band information.
* ANONYMOUS::               Mechanism for anonymous access to resources.
* PLAIN::                   Clear text username and password.
* LOGIN::                   Non-standard clear text username and password.
* CRAM-MD5::                Challenge-Response Authentication Mechanism.
* DIGEST-MD5::              Digest Authentication.
* NTLM::                    Microsoft NTLM authentication.
* SECURID::                 Authentication using tokens.
* GSSAPI::                  GSSAPI (Kerberos 5) authentication.
* KERBEROS_V5::             Experimental KERBEROS_V5 authentication.
@end menu

@node EXTERNAL
@section The EXTERNAL mechanism

The EXTERNAL mechanism is used to authenticate a user to SASL when
SASL is used in an environment which has already authenticated the
user.  It is often used within TLS or IPSEC protected channels.

This mechanism is only enabled in the server if you implement the
callback below and set them in the library (@pxref{Callback
Functions}).  It is always enabled in the client as there are no
client callbacks.

@deftypefn Prototype int (*Gsasl_server_callback_external) (Gsasl_session_ctx * @var{ctx})

@var{ctx}:  libgsasl handle.

Type of callback function the application implements.  It should
return @code{GSASL_OK} if user is authenticated by out of band means,
otherwise @code{GSASL_AUTHENTICATION_ERROR}.

@end deftypefn

@node ANONYMOUS
@section The ANONYMOUS mechanism

The ANONYMOUS mechanism is used to ``authenticate'' clients to
anonymous services; or rather just indicate that the client wishes to
use the service anonymously.  The client sends a token, usually her
email address.

This mechanism is only enabled in the client and server if you
implement the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@deftypefn Prototype int (*Gsasl_client_callback_anonymous) (Gsasl_session_ctx * @var{ctx}, char * @var{out}, size_t * @var{outlen})

@var{ctx}:  libgsasl handle.

@var{out}:  output array with client token.

@var{outlen}:  on input the maximum size of the output array, on output
contains the actual size of the output array.

Type of callback function the application implements.  It should
populate the output array with some input from the user and set the
output array length, and return @code{GSASL_OK}, or fail with an error
code.

If OUT is NULL, the function should only populate the output length
field with the length, and return GSASL_OK.  This usage may be used by
the caller to allocate the proper buffer size.

@end deftypefn

@deftypefn Prototype int (*Gsasl_server_callback_anonymous) (Gsasl_session_ctx * @var{ctx}, const char * @var{token})

@var{ctx}:  libgsasl handle.

@var{ctx}:  output array with client token.

@var{ctx}:  on input the maximum size of the output array, on output
contains the actual size of the output array.  If OUT is

Type of callback function the application implements.  It should
return @code{GSASL_OK} if user should be permitted anonymous access,
otherwise @code{GSASL_AUTHENTICATION_ERROR}.

@end deftypefn

@node PLAIN
@section The PLAIN mechanism

The PLAIN mechanism uses username (authentication identity and
authorization identity) and password to authenticate users.  Two ways
of validating the user is provided, either by having the SASL
mechanism retrieve the raw password from the application and perform
the validation internally, or by calling the application with
authentication identity, authorization identity and password and let
it decide.  If both the validating and the retrieving callbacks are
specified by the application, the validating one will be used.

This mechanism is only enabled in the client and server if you
implement the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@include gsasl-callback-authorization.texi

@include gsasl-callback-authentication.texi

@include gsasl-callback-password.texi

@include gsasl-callback-validate.texi

@include gsasl-callback-retrieve.texi


@node LOGIN
@section The LOGIN mechanism

The LOGIN mechanism uses username (authorization identity only) and
password to authenticate users.  Two ways of validating the user is
provided, either by having the SASL mechanism retrieve the raw
password from the application and perform the validation internally,
or by calling the application with authorization identity and password
and let it decide.  If both the validating and the retrieving
callbacks are specified by the application, the validating one will be
used.

This mechanism is only enabled in the client and server if you
implement the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@include gsasl-callback-authorization.texi

@include gsasl-callback-password.texi

@include gsasl-callback-validate.texi

@include gsasl-callback-retrieve.texi

@node CRAM-MD5
@section The CRAM-MD5 mechanism

The CRAM-MD5 mechanism uses username (authorization identity only) and
password to authenticate users.  Only a hashed password is transfered,
which means that you cannot use normal policy deciding authentication
systems such as PAM which do not support extraction of passwords.  Two
ways of validating the user is provided, either by having the SASL
mechanism retrieve the raw password from the application and perform
the validation internally, or by calling the application with the
CRAM-MD5 challenge and response and let it decide.  If both the
validating and the retrieving callbacks are specified by the
application, the validating one will be used.

While not documented in the original CRAM-MD5 specification, this
implementation normalizes the username and the authorization identity
using the Unicode 3.2 NFKC form according to the proposed update of
CRAM-MD5.

This mechanism is only enabled in the client and server if you
implement the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@include gsasl-callback-authorization.texi

@include gsasl-callback-password.texi

@include gsasl-callback-retrieve.texi

@include gsasl-callback-cram-md5.texi

@node DIGEST-MD5
@section The DIGEST-MD5 mechanism

The DIGEST-MD5 mechanism is based on the same cryptographic operation
as CRAM-MD5 but supports more features, such as an authorization
identity (proxy authentication) and cryptographic protection of data.
Like CRAM-MD5, only a hashed password is transfered, which means that
you cannot use e.g. PAM as a backend since it does not support
extraction of passwords.  Two ways of validating the user is provided,
either by having the SASL mechanism retrieve the raw password from the
application and perform the validation internally, or by having the
SASL mechanism retrieve a hashed version of the secret.  The advantage
of using the latter method is that you do not need to store plain text
user passwords on the server, but rather a one-way hash of the
username, realm and password.  Still, this one-way hash of the secret
should be handled the same way as a clear text password.  The
advantage is that if someone steals the one-way hash she cannot
immediately read users' password.  If both the callbacks are specified
by the application, the one which retrieve the secret hash will be
used.

While not documented in the original DIGEST-MD5 specification, this
implementation normalizes the username and the authentication identity
using the Unicode 3.2 NFKC form according to the proposed update of
DIGEST-MD5.

This mechanism is only enabled in the client and server if you
implement the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@include gsasl-callback-authentication.texi

@include gsasl-callback-authorization.texi

@include gsasl-callback-password.texi

@include gsasl-callback-client-service.texi

@include gsasl-callback-retrieve.texi

@include gsasl-callback-digest-md5.texi

@node NTLM
@section The NTLM mechanism

The NTLM mechanism uses username (authorization identity only) and
password to authenticate users.  Only the client side is implemented.
This mechanism is only enabled in the client if you implement the
callbacks below and set them in the library (@pxref{Callback
Functions}).

Note: Libntlm uses assert() in some places, it may thus crash your
client if it is given bad input.

@include gsasl-callback-authorization.texi

@include gsasl-callback-password.texi

@node SECURID
@section The SECURID mechanism

The SECURID mechanism uses authentication and authorization identity
and a passcode from a hardware token to authenticate users.  This
mechanism is only enabled in the client and server if you implement
the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@include gsasl-callback-authentication.texi

@include gsasl-callback-authorization.texi

@include gsasl-callback-passcode.texi

@include gsasl-callback-securid.texi

@node GSSAPI
@section The GSSAPI mechanism

The GSSAPI mechanism uses a framework similar to SASL for
authenticating the user.  While GSSAPI can be implemented using many
techniques, libgsasl currently links with GSS, Heimdal or MIT Kerberos
and is limited to Kerberos 5 only.  The GSSAPI client mechanism
assumes the user acquired credentials (kerberos tickets) before it is
invoked (it will fail if this has not been done).  The client need
(via callbacks) the name of the service and the name of the user.  The
server needs the name of the service and a function that authorizes a
user.  This mechanism is only enabled in the client and server if you
implement the respectively callbacks below and set them in the library
(@pxref{Callback Functions}).

@include gsasl-callback-authentication.texi

@include gsasl-callback-client-service.texi

@include gsasl-callback-server-service.texi

@include gsasl-callback-gssapi.texi

@node KERBEROS_V5
@section The KERBEROS_V5 mechanism

The KERBEROS_V5 is an experimental mechanism, the protocol
specification is available on the GNU SASL homepage.  It can operate
in three modes, non-infrastructure mode, infrastructure mode and
proxied infrastructure mode.  Currently only non-infrastructure mode
is supported.

In the non-infrastructure mode, it works as a superset of most
features provided by PLAIN, CRAM-MD5, DIGEST-MD5 and GSSAPI while at
the same time building on what is believed to be proven technology
(the RFC 1510 network security system).  The non-infrastructure mode
is chosen when the Gsasl_client_callback_authorization_id callback
prototype is implemented by the application.  In non-infrastructure
mode, the client must specify (via callbacks) the name of the user,
and optionally the server name and realm.  The server must be able to
retrieve passwords given the name of the user.

In the infrastructure mode (proxied or otherwise), it allows clients
and servers to authenticate via SASL in an RFC 1510 environment, using
a trusted third party, a ``Key Distribution Central''.  In the normal
mode, clients aquire tickets out of band and then invokes a one
roundtrip AP-REQ and AP-REP exchange.  In the proxied mode, which can
be used by clients without IP addresses or without connectivity to the
KDC (e.g., when the KDC is IPv4 and the client is IPV6-only), the
client uses the server to proxy ticket requests and finishes with the
AP-REQ/AP-REP exchange.  In infrastructure mode (proxied or
otherwise), the client nor server need to implement any callbacks
(this will likely change later, to allow a server to authorize users,
similar to the GSSAPI callback).

@include gsasl-callback-authentication.texi

@include gsasl-callback-authorization.texi

@include gsasl-callback-password.texi

@include gsasl-callback-retrieve.texi

@c **********************************************************
@c *****************  Global Functions  *********************
@c **********************************************************
@node Global Functions
@chapter Global Functions

@include texi/init.c.texi
@include texi/done.c.texi
@include texi/listmech.c.texi
@include texi/supportp.c.texi
@include texi/suggest.c.texi


@c **********************************************************
@c ******************  Callback Functions  ******************
@c **********************************************************
@node Callback Functions
@chapter Callback Functions
@cindex Callbacks

@include texi/callback.c.texi
@include texi/callback-s.c.texi
@include texi/callback-c.c.texi


@c **********************************************************
@c *****************  Session Functions  ********************
@c **********************************************************
@node Session Functions
@chapter Session Functions
@cindex SASL sessions

@include texi/xstart.c.texi
@include texi/xstep.c.texi
@include texi/xfinish.c.texi
@include texi/xcode.c.texi



@c **********************************************************
@c *******************  Utilities  **************************
@c **********************************************************
@node Utilities
@chapter Utilities

@include texi/stringprep.c.texi
@include texi/base64.c.texi
@include texi/md5pwd.c.texi



@c **********************************************************
@c *******************  Errors  ****************************
@c **********************************************************
@node Error Handling
@chapter Error Handling
@cindex Error Handling

Most functions in `Libgsasl' are returning an error if they fail.  For
this reason, the application should always catch the error condition and
take appropriate measures, for example by releasing the resources and
passing the error up to the caller, or by displaying a descriptive
message to the user and cancelling the operation.

Some error values do not indicate a system error or an error in the
operation, but the result of an operation that failed properly.

@menu
* Error values::                A list of all error values used.
* Error strings::               How to get a descriptive string from a value.
@end menu

@node Error values
@section Error values

Errors are returned as an @code{int}.  Except for the OK case an
application should always use the constants instead of their numeric
value.  Applications are encouraged to use the constants even for OK
as it improves readability.  Possible values are:

@table @code
@item GSASL_OK
This value indicates success.  The value of this error is guaranteed
to always be @code{0} so you may use it in boolean constructs.

@include gsasl-api-error-labels.texi

@end table

@node Error strings
@section Error strings

@include texi/error.c.texi

@c **********************************************************
@c ***********************  Examples  ***********************
@c **********************************************************
@node Examples
@chapter Examples
@cindex Examples

This chapter contains example code which illustrate how `Libgsasl' can
be used when writing your own application.

@menu
* Example 1::
@end menu

@node Example 1
@section Example 1

This is the minimal program which uses `Libgsasl' (including
internationalization features) without doing anything.

@example
@include gsasl-example1.c
@end example


@c **********************************************************
@c *******************  Acknowledgements  *******************
@c **********************************************************
@node Acknowledgements
@chapter Acknowledgements

The makefiles, manuals, etc borrowed much from Libgcrypt written by
Werner Koch.

Cryptographic functions for some SASL mechanisms uses Libgcrypt by
Werner Koch et al.  The NTLM mechanism uses Libntlm by Grant Edwards
et al, using code from Samba written by Andrew Tridgell, and now
maintained by Simon Josefsson.  The KERBEROS_V5 mechanism uses Shishi
by Simon Josefsson.  The GSSAPI mechanism uses a GSS-API
implementation, such as GSSLib by Simon Josefsson.

This manual borrows text from the SASL specification.

@c **********************************************************
@c ********************  Invoking gsasl  ********************
@c **********************************************************
@node Invoking gsasl
@chapter Invoking gsasl

@pindex gsasl
@cindex invoking @command{gsasl}
@cindex command line

@majorheading Name

GNU SASL (gsasl) -- Command line interface to libgsasl.

@majorheading Description
@code{gsasl} is the main program of GNU SASL.

This section only lists the commands and options available.

Mandatory or optional arguments to long options are also mandatory or
optional for any corresponding short options.

@majorheading Commands
@code{gsasl} recognizes these commands:

@verbatim
  -c, --client               Act as client.
      --client-mechanisms    Write name of supported client mechanisms
                             separated by space to stdout.
  -s, --server               Act as server.
      --server-mechanisms    Write name of supported server mechanisms
                             separated by space to stdout.
@end verbatim

@majorheading Network Options

Normally the SASL negotiation is performed on the terminal, with
reading from stdin and writing to stdout.  It is also possible to
perform the negotiation with a server over a TCP network connection.

@verbatim
      --connect=HOSTNAME[:SERVICE]
                             Connect to TCP server and negotiate on stream
                             instead of stdin/stdout. SERVICE is the protocol
                             service, or an integer denoting the port, and
                             defaults to 143 (imap) if not specified. Also sets
                             the --hostname default.
@end verbatim

@majorheading Miscellaneous Options:

These parameters affect overall behaviour.

@verbatim
  -d, --application-data     After authentication, read data from stdin and run
                             it through the mechanism's security layer and
                             print it base64 encoded to stdout. The default is
                             to terminate after authentication.
      --imap                 Use a IMAP-like logon procedure (client only).
                             Also sets the --service default to "imap".
  -m, --mechanism=STRING     Mechanism to use.
      --no-client-first      Disallow client to send data first (client only).
@end verbatim

@majorheading SASL Mechanism Options

These options modify the behaviour of the callbacks (@pxref{Callback
Functions}) in the library.  The default is the query the user on the
terminal.

@verbatim
  -a, --authentication-id=STRING   Identity of credential owner.
      --disable-cleartext-validate
                             Disable cleartext validate hook, forcing server to
                             prompt for password.
      --enable-cram-md5-validate   Validate CRAM-MD5 challenge and response
                             interactively.
      --hostname=STRING      Set the name of the server with the requested
                             service.
  -n, --anonymous-token=STRING   Token for anonymous authentication, usually
                             mail address (ANONYMOUS only).
  -p, --password=STRING      Password for authentication (insecure for
                             non-testing purposes).
      --passcode=NUMBER      Passcode for authentication (SECURID only).
      --quality-of-protection=<auth | auth-int | auth-conf>
                             How application payload will be protected.  "auth"
                             means no protection, "auth-int" means integrity
                             protection, "auth-conf" means integrity and
                             confidentialiy protection.  Currently only used by
                             DIGEST-MD5, where the default is "auth-conf".
  -r, --realm=STRING         Realm (may be given more than once iff server).
                             Defaults to hostname.
      --service=STRING       Set the requested service name (should be a
                             registered GSSAPI host based service name).
      --service-name=STRING  Set the generic server name in case of a
                             replicated server (DIGEST-MD5 only).
  -x, --maxbuf=NUMBER        Indicate maximum buffer size (DIGEST-MD5 only).
  -z, --authorization-id=STRING   Identity to request service for.
@end verbatim

@majorheading Other Options

These are some standard parameters.

@verbatim
  -q, --quiet, --silent      Don't produce any diagnostic output.
  -v, --verbose              Produce verbose output.

  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version
@end verbatim

@c **********************************************************
@c *******************  Appendices  *************************
@c **********************************************************

@node Copying This Manual
@appendix Copying This Manual

@menu
* GNU Free Documentation License::  License for copying this manual.
@end menu

@include fdl.texi

@include gpl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@node Function and Data Index
@unnumbered Function and Data Index

@printindex fn

@summarycontents
@contents
@bye
